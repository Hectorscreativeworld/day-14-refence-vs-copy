<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
</head>

<body>
  <h1>JS Reference VS Copy</h1>
  <h3>Below is whats in the console.log</h3>
  <p>/ start with strings, numbers and booleans</p>
  <p>// let age = 100;</p>
  <p>// let age2 = age;</p>
  <p>// console.log(age, age2);</p>
  <p>// age = 200;</p>
  <p>// console.log(age, age2);</p>
  <p>// let name = 'Hector';</p>
  <p>// let name2 = name;</p>
  <p>// console.log(name, name2);</p>
  <p>// name = 'Hector';</p>
  <p>// console.log(name, name2);</p>
  <p>// Let's say we have an array</p>
  <p>const players = ['Hector', 'Sarah', 'Ryan', 'Poppy'];</p>
  <p> // and we want to make a copy of it.</p>
  <p>const team = players;</p>
  <p>console.log(players, team);</p>
  <p>// You might think we can just do something like this:</p>
  <p>// team[3] = 'Lux';</p>
  <p>// however what happens when we update that array?</p>
  <p>// now here is the problem!</p>
  <p>// oh no - we have edited the original array too!</p>
  <p>// Why? It's because that is an array reference, not an array copy. They both point to the same array!</p>
  <p>// So, how do we fix this? We take a copy instead!</p>
  <p>const team2 = players.slice();</p>
  <p>// one way</p>
  <p>// or create a new array and concat the old one in</p>
  <p>const team3 = [].concat(players);</p>
  <p>// or use the new ES6 Spread</p>
  <p>const team4 = [...players];</p>
  <p>team4[3] = 'heeee hawww';</p>
  <p>console.log(team4);</p>
  <p>const team5 = Array.from(players);</p>
  <p>// now when we update it, the original one isn't changed</p>
  <p>// The same thing goes for objects, let's say we have a person object</p>
  <p>// with Objects</p>
  <p>const person = {</p>
  <p>name: 'Hector Velez',</p>
  <p>age: 80</p>
  <p>};</p>
  <p>// and think we make a copy:</p>
  <p>// const captain = person;</p>
  <p>// captain.number = 99;</p>
  <p>// how do we take a copy instead?</p>
  <p>const cap2 = Object.assign({}, person, { number: 99, age: 12 });</p>
  <p>console.log(cap2);</p>
  <p>// We will hopefully soon see the object ...spread</p>
  <p>// const cap3 = {...person};</p>
  <p>// Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you
  </p>
  <p>should think twice before using it.</p>
  <p>const Hector = {</p>
  <p>name: 'Hector',</p>
  <p>age: 99,</p>
  <p>social: {</p>
  <p>twitter: '@Hector',</p>
  <p>facebook: 'Hector.developer'</p>
  <p>}</p>
  <p>};</p>
  <p>console.clear();</p>
  <p>console.log(Hector);</p>
  <p>const dev = Object.assign({}, Hector);</p>
  <p>const dev2 = JSON.parse(JSON.stringify(Hector));</p>
  </p>

  <script>
    // start with strings, numbers and booleans
    // let age = 100;
    // let age2 = age;
    // console.log(age, age2);
    // age = 200;
    // console.log(age, age2);
    // let name = 'Hector';
    // let name2 = name;
    // console.log(name, name2);
    // name = 'Hector';
    // console.log(name, name2);
    // Let's say we have an array
    const players = ['Hector', 'Sarah', 'Ryan', 'Poppy'];
    // and we want to make a copy of it.
    const team = players;
    console.log(players, team);
    // You might think we can just do something like this:
    // team[3] = 'Lux';
    // however what happens when we update that array?
    // now here is the problem!
    // oh no - we have edited the original array too!
    // Why? It's because that is an array reference, not an array copy. They both point to the same array!
    // So, how do we fix this? We take a copy instead!
    const team2 = players.slice();
    // one way
    // or create a new array and concat the old one in
    const team3 = [].concat(players);
    // or use the new ES6 Spread
    const team4 = [...players];
    team4[3] = 'heeee hawww';
    console.log(team4);
    const team5 = Array.from(players);
    // now when we update it, the original one isn't changed
    // The same thing goes for objects, let's say we have a person object
    // with Objects
    const person = {
      name: 'Hector Velez',
      age: 80
    };
    // and think we make a copy:
    // const captain = person;
    // captain.number = 99;
    // how do we take a copy instead?
    const cap2 = Object.assign({}, person, {
      number: 99,
      age: 12
    });
    console.log(cap2);
    // We will hopefully soon see the object ...spread
    // const cap3 = {...person};
    // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
    const Hector = {
      name: 'Hector',
      age: 99,
      social: {
        twitter: '@Hector',
        facebook: 'Hector.developer'
      }
    };
    console.clear();
    console.log(Hector);
    const dev = Object.assign({}, Hector);
    const dev2 = JSON.parse(JSON.stringify(Hector));
  </script>

</body>

</html>